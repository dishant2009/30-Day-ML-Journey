# -*- coding: utf-8 -*-
"""NumpyArrayBroadcasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bNmyNx3Dgg1Ru1vefTap7GmWyGXd_sOZ
"""

def broadcast_shapes(shape1, shape2):
    """
    Compute the broadcasted shape of two arrays following NumPy's exact algorithm.

    Broadcasting allows operations between arrays of different shapes by virtually
    "stretching" arrays to compatible shapes without copying data.

    Args:
        shape1 (tuple): Shape tuple of first array (e.g., (3, 4, 5))
        shape2 (tuple): Shape tuple of second array (e.g., (4, 1))

    Returns:
        tuple: The broadcasted shape that both arrays can be stretched to

    Raises:
        ValueError: If the shapes are not broadcast-compatible

    Examples:
        >>> broadcast_shapes((3, 4), (4,))
        (3, 4)
        >>> broadcast_shapes((5, 1, 3), (1, 4, 1))
        (5, 4, 3)
        >>> broadcast_shapes((3, 4), (5, 6))  # Incompatible
        ValueError: operands could not be broadcast together with shapes (3, 4) (5, 6)
    """

    # Convert to lists for easier manipulation
    s1 = list(shape1)
    s2 = list(shape2)

    # STEP 1: Left-pad the shorter shape with 1s
    # This is the "left-padding" part of NumPy's algorithm
    # We make both shapes the same length by adding 1s to the left
    max_len = max(len(s1), len(s2))

    # Pad shape1 with 1s on the left if it's shorter
    while len(s1) < max_len:
        s1.insert(0, 1)

    # Pad shape2 with 1s on the left if it's shorter
    while len(s2) < max_len:
        s2.insert(0, 1)

    # STEP 2: Check compatibility and compute result shape
    # Work through each dimension pair from left to right
    result_shape = []

    for i in range(max_len):
        dim1 = s1[i]
        dim2 = s2[i]

        # Broadcasting rule: dimensions are compatible if:
        # 1. They are equal, OR
        # 2. One of them is 1
        if dim1 == dim2:
            # Case 1: Dimensions are equal - use either one
            result_shape.append(dim1)
        elif dim1 == 1:
            # Case 2a: First dimension is 1 - broadcast to second dimension
            result_shape.append(dim2)
        elif dim2 == 1:
            # Case 2b: Second dimension is 1 - broadcast to first dimension
            result_shape.append(dim1)
        else:
            # Case 3: Incompatible - neither equal nor one is 1
            raise ValueError(
                f"operands could not be broadcast together with shapes "
                f"{shape1} {shape2}"
            )

    return tuple(result_shape)


def demonstrate_broadcasting():
    """
    Demonstrate various broadcasting scenarios with detailed explanations.
    """

    print("=== NumPy Broadcasting Algorithm Demonstration ===\n")

    # Test cases with explanations
    test_cases = [
        # (shape1, shape2, description)
        ((3, 4), (4,), "2D array with 1D array"),
        ((5, 1, 3), (1, 4, 1), "3D arrays with singleton dimensions"),
        ((8, 1, 6, 1), (7, 1, 5), "4D with 3D array"),
        ((3, 4), (3, 4), "Identical shapes"),
        ((1,), (5,), "Broadcasting scalar-like to vector"),
        ((2, 1), (1, 3), "2D arrays with different singleton dims"),
        ((3, 4), (5, 6), "Incompatible shapes (should fail)"),
        ((2, 3, 4), (3, 1), "3D with 2D array"),
    ]

    for i, (shape1, shape2, description) in enumerate(test_cases, 1):
        print(f"Test {i}: {description}")
        print(f"Shape 1: {shape1}")
        print(f"Shape 2: {shape2}")

        try:
            result = broadcast_shapes(shape1, shape2)
            print(f"Result:  {result}")
            print("✓ Compatible")
        except ValueError as e:
            print(f"Error: {e}")
            print("✗ Incompatible")

        print("-" * 50)


def explain_broadcasting_step_by_step(shape1, shape2):
    """
    Show the step-by-step process of broadcasting two shapes.
    """
    print(f"\n=== Step-by-step Broadcasting: {shape1} and {shape2} ===")

    s1 = list(shape1)
    s2 = list(shape2)

    print(f"Original shapes:")
    print(f"  Shape 1: {tuple(s1)}")
    print(f"  Shape 2: {tuple(s2)}")

    # Step 1: Left-padding
    max_len = max(len(s1), len(s2))
    print(f"\nStep 1: Left-pad to length {max_len}")

    while len(s1) < max_len:
        s1.insert(0, 1)
        print(f"  Padded shape 1: {tuple(s1)}")

    while len(s2) < max_len:
        s2.insert(0, 1)
        print(f"  Padded shape 2: {tuple(s2)}")

    # Step 2: Dimension-by-dimension check
    print(f"\nStep 2: Check compatibility dimension by dimension")
    result_shape = []

    for i in range(max_len):
        dim1, dim2 = s1[i], s2[i]
        print(f"  Dimension {i}: {dim1} vs {dim2}", end=" -> ")

        if dim1 == dim2:
            result_shape.append(dim1)
            print(f"{dim1} (equal)")
        elif dim1 == 1:
            result_shape.append(dim2)
            print(f"{dim2} (broadcast first)")
        elif dim2 == 1:
            result_shape.append(dim1)
            print(f"{dim1} (broadcast second)")
        else:
            print("INCOMPATIBLE!")
            return None

    print(f"\nFinal broadcasted shape: {tuple(result_shape)}")
    return tuple(result_shape)


# Example usage and testing
if __name__ == "__main__":
    # Run demonstrations
    demonstrate_broadcasting()

    # Show step-by-step examples
    explain_broadcasting_step_by_step((3, 4), (4,))
    explain_broadcasting_step_by_step((5, 1, 3), (1, 4, 1))

    # Test with some real examples
    print("\n=== Quick Tests ===")

    examples = [
        ((3, 1), (1, 4)),      # Should work: (3, 4)
        ((8, 1, 6, 1), (7, 1, 5)),  # Should work: (8, 7, 6, 5)
        ((3, 4), (5, 4)),      # Should fail: first dim incompatible
    ]

    for shape1, shape2 in examples:
        try:
            result = broadcast_shapes(shape1, shape2)
            print(f"{shape1} + {shape2} = {result}")
        except ValueError as e:
            print(f"{shape1} + {shape2} = ERROR: {e}")