# -*- coding: utf-8 -*-
"""NUMPY5June.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kM2536gvR-Z2rTNBlq0mrEGWZ3xhEmS0
"""

import numpy as np
a = np.arange(15)

a

a.reshape(3,5)

a

a = a.reshape(3,5)

a.ndim

a.dtype.name

a.itemsize

a.size

b = np.array([3,4,5])

b

#Array Creation

a = np.array([1,2,3])
a.dtype

b= np.array([1.2,2.3,4.3])

b.dtype

b = np.array([(1,2,3),(3,4,5)])

b

c = np.array([(1,2),(3,4)], dtype = complex)

c

np.zeros(3)

np.zeros((3,4))

np.arange(1,2,0.2)

np.arange(0,2, 0.1)

from numpy import pi

"""linspace is used when we know the number of elements we need, cause in arange we do not know the number of elements"""

np.linspace(0,2,9)

x = np.linspace(0,2*pi,100)

f = np.sin(x)

f

# Printing arrays

a = np.arange(6)

print(a)

a

b = np.arange(12).reshape(4,3)

b

print(np.arange(500))

b = np.arange(4)

b**2

print(b)

A = np.array([(1,2),(2,3)])
B = np.array([(4,5),(5,6)])

A*B

A@B #matrix product

A.dot(B)

#when operating with different arrays we see that the type of the resulting array corresponds to the more general one or the more precise one

a = np.ones(3, dtype = np.int32)

b = np.linspace(0,pi,3)

b

b.dtype

b.dtype.name

c = a+b
c

c.dtype.name

a = np.random.random((2,3))

a

a.sum()

print(a.sum())

a.min()

a.max()

b = np.arange(12).reshape(3,4)

b.sum(axis = 0) #when we give axis = 0, then it gives us the sum of the columns

b.min(axis = 1) # when we keep axis = 1, then it gives us the min of the rows.

b.cumsum(axis = 1) # the cumulative sum across the rows

#Universal functions

B = np.arange(3)
B

np.exp(B)

np.sqrt(B)

a = np.arange(10)**3

a

a[2], a[2:5]

a[2]

a[:6:2]= -1000

a

# for access the array in reverse using slicing:

a[ : :-1]

def f(x,y):
  return 10*x+y

b = np.fromfunction(f,(5,4),dtype = int)
b

b[2,3]

b[0:5,1]

b[1:3, :]

b[-1]   # this is equal to the last row. Equivalent to b[-1, :]

c = np.random.random((5,4,3))

c

c.shape

c.ndim

c[1,...]

c[..., 2]

for row in c:
  print(row)

for element in c.flat: # we can use flat if we want to perform an operation on each element in the array
  print(element)

#Shape Manipulation

a = np.floor(10*np.random.random((3,4)))

a

a.ravel()

a.reshape(6,2)

a.reshape(6,1)

a.T

# we see that reshape returns its argument with amodified shape, while the resize function will actually modify the array itself

a = np.floor(10*np.random.random((2,2)))
b = np.floor(10*np.random.random((2,2)))

np.vstack((a,b))

np.hstack((a,b))

