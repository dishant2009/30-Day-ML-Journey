# -*- coding: utf-8 -*-
"""RollingWindow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pmhkGO_nRjjtbwgpSTp5r_rFYCIyzYTb
"""

import numpy as np
from numpy.lib.stride_tricks import as_strided


def rolling_window(arr, window, axis=0):
    """
    Create a rolling window view of an array using stride tricks.

    This function creates overlapping windows along the specified axis without
    copying any data - it's a pure view that shares memory with the original array.

    Args:
        arr (np.ndarray): Input array
        window (int): Size of the rolling window
        axis (int): Axis along which to create windows (default: 0)

    Returns:
        np.ndarray: View with rolling windows, adds one dimension

    Examples:
        >>> arr = np.array([1, 2, 3, 4, 5])
        >>> rolling_window(arr, 3)
        array([[1, 2, 3],
               [2, 3, 4],
               [3, 4, 5]])
    """

    # Validate inputs
    if window <= 0:
        raise ValueError("Window size must be positive")
    if axis < 0:
        axis = arr.ndim + axis  # Handle negative axis
    if axis >= arr.ndim:
        raise ValueError(f"Axis {axis} out of bounds for array with {arr.ndim} dimensions")
    if arr.shape[axis] < window:
        raise ValueError(f"Window size {window} larger than array size {arr.shape[axis]} along axis {axis}")

    # Get original array properties
    original_shape = arr.shape
    original_strides = arr.strides

    # Calculate new shape - the rolling axis gets reduced, new axis added
    new_shape = list(original_shape)
    new_shape[axis] = original_shape[axis] - window + 1  # Number of possible windows
    new_shape.insert(axis + 1, window)  # Insert window dimension after the rolling axis

    # Calculate new strides - all original strides remain, plus window stride
    new_strides = list(original_strides)
    new_strides.insert(axis + 1, original_strides[axis])  # Window moves by original stride

    # Create the strided view
    return as_strided(arr, shape=new_shape, strides=new_strides, writeable=False)


def demonstrate_rolling_window():
    """
    Comprehensive demonstration of rolling_window functionality.
    """

    print("=== Rolling Window with as_strided Demo ===\n")

    # Example 1: Basic 1D case
    print("1. Basic 1D rolling window:")
    arr1d = np.array([1, 2, 3, 4, 5, 6])
    print(f"Original: {arr1d}")
    windows1d = rolling_window(arr1d, 3)
    print(f"Rolling windows (size 3):")
    print(windows1d)
    print(f"Shape change: {arr1d.shape} → {windows1d.shape}")
    print()

    # Example 2: 2D array, rolling along axis 0 (rows)
    print("2. 2D array - rolling along rows (axis=0):")
    arr2d = np.array([[1, 2, 3],
                      [4, 5, 6],
                      [7, 8, 9],
                      [10, 11, 12]])
    print("Original array:")
    print(arr2d)
    windows2d_axis0 = rolling_window(arr2d, 2, axis=0)
    print("Rolling windows (size 2, axis=0):")
    print(windows2d_axis0)
    print(f"Shape change: {arr2d.shape} → {windows2d_axis0.shape}")
    print()

    # Example 3: 2D array, rolling along axis 1 (columns)
    print("3. 2D array - rolling along columns (axis=1):")
    print("Original array:")
    print(arr2d)
    windows2d_axis1 = rolling_window(arr2d, 2, axis=1)
    print("Rolling windows (size 2, axis=1):")
    print(windows2d_axis1)
    print(f"Shape change: {arr2d.shape} → {windows2d_axis1.shape}")
    print()

    # Example 4: 3D case
    print("4. 3D array example:")
    arr3d = np.arange(24).reshape(2, 3, 4)
    print("Original 3D array:")
    print(arr3d)
    windows3d = rolling_window(arr3d, 2, axis=1)
    print("Rolling windows (size 2, axis=1):")
    print(windows3d)
    print(f"Shape change: {arr3d.shape} → {windows3d.shape}")
    print()


def prove_memory_sharing():
    """
    Prove that rolling_window creates a view that shares memory with original.
    """

    print("=== Memory Sharing Proof ===\n")

    # Create test array
    original = np.array([10, 20, 30, 40, 50, 60], dtype=np.int32)
    print(f"Original array: {original}")
    print(f"Original memory address: {hex(original.ctypes.data)}")
    print(f"Original array ID: {id(original)}")
    print()

    # Create rolling window view
    windows = rolling_window(original, 3)
    print("Rolling windows:")
    print(windows)
    print(f"Windows memory address: {hex(windows.ctypes.data)}")
    print(f"Windows array ID: {id(windows)}")
    print()

    # Test 1: Check if they share the same base
    print("1. Base array check:")
    print(f"   Original base: {original.base}")
    print(f"   Windows base: {windows.base}")
    print(f"   Same base? {windows.base is original}")
    print()

    # Test 2: Check memory addresses
    print("2. Memory address comparison:")
    print(f"   Same memory start? {original.ctypes.data == windows.ctypes.data}")
    print()

    # Test 3: Modify original and check if windows reflect the change
    print("3. Memory sharing test - modify original:")
    print(f"   Before: original[1] = {original[1]}")
    print(f"   Before: windows = ")
    print(f"   {windows}")

    # Modify original array
    original[1] = 999

    print(f"   After: original[1] = {original[1]}")
    print(f"   After: windows = ")
    print(f"   {windows}")
    print(f"   Windows updated automatically? {999 in windows}")
    print()

    # Test 4: Check memory overlap with np.shares_memory
    print("4. NumPy memory sharing check:")
    print(f"   np.shares_memory(original, windows): {np.shares_memory(original, windows)}")
    print()

    # Test 5: Demonstrate stride information
    print("5. Stride analysis:")
    print(f"   Original strides: {original.strides}")
    print(f"   Windows strides: {windows.strides}")
    print(f"   Original itemsize: {original.itemsize} bytes")
    print()


def explain_stride_mechanics():
    """
    Detailed explanation of how strides work in rolling windows.
    """

    print("=== Understanding Stride Mechanics ===\n")

    # Simple example to explain strides
    arr = np.array([1, 2, 3, 4, 5], dtype=np.int32)  # 4 bytes per int32
    print(f"Original array: {arr}")
    print(f"Original shape: {arr.shape}")
    print(f"Original strides: {arr.strides} (bytes between elements)")
    print(f"Memory layout: Each element is 4 bytes apart")
    print()

    # Create rolling window
    windows = rolling_window(arr, 3)
    print("Rolling windows:")
    print(windows)
    print(f"New shape: {windows.shape}")
    print(f"New strides: {windows.strides}")
    print()

    print("Stride explanation:")
    print(f"  - First stride ({windows.strides[0]} bytes): Jump between window starts")
    print(f"  - Second stride ({windows.strides[1]} bytes): Jump between elements within window")
    print()

    # Show memory addresses to prove the concept
    print("Memory addresses of each element in the view:")
    for i in range(windows.shape[0]):
        for j in range(windows.shape[1]):
            addr = windows[i, j].ctypes.data
            print(f"  windows[{i},{j}] = {windows[i,j]} at address {hex(addr)}")
    print()

    print("Original array element addresses:")
    for i in range(len(arr)):
        addr = arr[i].ctypes.data
        print(f"  arr[{i}] = {arr[i]} at address {hex(addr)}")


def benchmark_memory_efficiency():
    """
    Compare memory usage: stride view vs. explicit copying.
    """

    print("=== Memory Efficiency Comparison ===\n")

    # Create a larger array for meaningful comparison
    large_arr = np.arange(1000000, dtype=np.float64)  # 8MB array
    window_size = 100

    print(f"Original array size: {large_arr.nbytes / 1024 / 1024:.2f} MB")
    print(f"Window size: {window_size}")
    print(f"Number of windows: {len(large_arr) - window_size + 1}")
    print()

    # Method 1: Using our stride-based rolling window (no copy)
    stride_windows = rolling_window(large_arr, window_size)
    print("Stride-based approach:")
    print(f"  Result shape: {stride_windows.shape}")
    print(f"  Memory used: {stride_windows.nbytes / 1024 / 1024:.2f} MB")
    print(f"  Shares memory: {np.shares_memory(large_arr, stride_windows)}")
    print()

    # Method 2: Naive copying approach (for comparison)
    def naive_rolling_window(arr, window):
        """Naive implementation that copies data"""
        result = []
        for i in range(len(arr) - window + 1):
            result.append(arr[i:i+window].copy())  # .copy() forces a copy
        return np.array(result)

    copied_windows = naive_rolling_window(large_arr, window_size)
    print("Copy-based approach:")
    print(f"  Result shape: {copied_windows.shape}")
    print(f"  Memory used: {copied_windows.nbytes / 1024 / 1024:.2f} MB")
    print(f"  Shares memory: {np.shares_memory(large_arr, copied_windows)}")
    print()

    memory_ratio = copied_windows.nbytes / stride_windows.nbytes
    print(f"Memory efficiency: Stride approach uses {memory_ratio:.1f}x less memory!")


# Run all demonstrations
if __name__ == "__main__":
    demonstrate_rolling_window()
    prove_memory_sharing()
    explain_stride_mechanics()
    benchmark_memory_efficiency()